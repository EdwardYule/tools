### 尝试添加一个全局的修饰符，可以实现防抖节流

``` javascript
@click.throttle="doSomething"
@input.throttle="doSomething"
```

  失败。本想通过拦截Vue.directive函数，来实现全局指令的修改，发现只能修改自定义的指令，对于Vue自带的比如v-on，v-bind指令无效。Vue内部应该不是使用Vue.directive函数来注册bind和on的。要么就是找出Vue内部如何注册原生指令的，要么就换个方式。

### 新的自定义指令，但是这样就不能对所有的事件生效

  比如需要单独写一个新的click，新的input，这样也是比较麻烦

### 看看能不能从$on中得到一些线索

  $on灵活性不够，只能判断事件名，其他的无从判断

### 直接使用函数

``` javascript
import throttle from "./utils";
export default {
  methods: {
    doSomething: throttle(function(){
      console.log(this);
    })
  }
}
```

经权衡，这种方法反而是最实用的。首先，不会全局性的破坏任何功能，原本的click照常可以使用，并且，不管是input也好，click也好，所有的事件都可以使用。唯一美中不足的是，每次使用需要重复的引入，可以再想办法解决这一点。

事实上，我们发现这其实是装饰器模式。

### 关于装饰器的引入

我们写了不少装饰器，但是，怎么使用呢？

如果每次都需要引用，未免有点繁琐，我们希望把它注册成全局的功能。固然可以用webpack在每个文件中自动引入，但那只是局部引入的自动操作版本。有没有什么办法更加优雅呢？

是否可以结合在组件上，或者指令上？

如果结合在组件上，那么就不能局限在某个特定的组件，比如按钮，输入框，这样工作量会很大。而应该写成某个抽象的组件，比如

``` javascript
<Decorator></Decorator>
```

### 结论

感觉探索无果，除了使用webpack，感觉没有其他办法可以在所有作用域中引入一个函数。
那就局部引用吧，使用组件的方式感觉也是不太可行的，思考一下。
